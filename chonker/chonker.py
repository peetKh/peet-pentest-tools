#! /usr/bin/env python3

# ---  Chonker ---
#
#    /\_/\          [ The Lazy Net Cat ]
#   ( o.o )  .
#   /     \   ;
#  /  U U  \ /      Very simple reverse shell listener with history
# (___)_(___)       based autocompletion for the lazy pentester
#
#
#   Other options:
#     * rlwrap nc -nlvp 4444
#     * https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/
#
#   NOTES:
#       - Sometime the prompt does not appear in the right place after
#         receiving a response.
#   TODO:
#       - Make quit sequence a bit cleaner
#
#   DISCLAIMER: USE IT AT YOUR OWN RISK !!
#   It's safer to keep a primary revserse shell on netcat, and then from there,
#   launch a secondary reverse shell on another port to use with Chonker.
#   If Chonker crashes, you'll still have your netcat revser shell.

import threading
import socket
import sys
import random
import select
from prompt_toolkit import PromptSession
from prompt_toolkit.history import InMemoryHistory
from prompt_toolkit.history import FileHistory
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from prompt_toolkit.patch_stdout import patch_stdout
from prompt_toolkit.styles import Style
import time

chonkerVersion = "0.1.2"

chonkerBanner = r"""
-------------------- Chonker v%s -------------------------------------------
   /\_/\          [ The Lazy Net Cat ]
  ( o.o )  .
  /     \   ;
 /  U U  \ /      Very simple reverse shell listener with history
(___)_(___)       based autocompletion for the lazy pentester
""" % chonkerVersion
import argparse

parser = argparse.ArgumentParser(
    description = "\n",
    formatter_class = argparse.RawTextHelpFormatter)
parser.add_argument("port", type=int, nargs=1, help="Listening port")
parser.add_argument("-b", type=str, nargs=1, help="Bind address", default='0.0.0.0')
parser.add_argument("-H", type=str, nargs=1, help="History file", default='./revshell_history')
parser.add_argument("-C",
    help = "Send CRLF for new lines",
    action = 'store_true', default = False)
args = parser.parse_args()
print(chonkerBanner)
bindAddress = args.b
localport = args.port[0]
historyFile = args.H
fCrLf = args.C
print(bindAddress, localport, historyFile, fCrLf)
sys.exit

if fCrLf:
    nlBytes = b'\r\n'
else:
    nlBytes = b'\n'

promptStr = ''

def listenerThrd(rsock, cltSkt):
    sktList = (rsock, cltSkt)
    while True :
        read_sockets, write_socket, error_socket = select.select(sktList,[],[])
        for s in read_sockets:
            if s is cltSkt:
                msg = cltSkt.recv(2048)
                if not msg:
                    print("[-] Connection closed.")
                    cltSkt.close()
                    rsock.close()
                    sys.exit()
                try:
                    sMsg = msg.decode()
                except:
                    # Response could not be decoded
                    # Most certainly contains binary data
                    sMsg = "[binary:]\n" + "\n".join(repr(m)[2:-2] for m in msg.split(b'\n'))
                print(sMsg, end='', flush=True)
            elif s is rsock:
                cmd = rsock.recv(1024)
                if not cmd:
                    print('ERROR: Internal socket pair borken')
                    sys.exit()
                if cmd.strip() == b'%chonker:exit':
                    print('[-] Closing connection')
                    cltSkt.close()
                    rsock.close()
                    sys.exit()
                #print("Sending: ", cmd)
                cltSkt.sendall(cmd + nlBytes)

lstnSkt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
lstnSkt.bind((bindAddress, localport))
lstnSkt.listen(10)
print("[*] Listening on %s:%d." % (bindAddress,localport))

cltSkt, clientAddr = lstnSkt.accept()
cltIp = clientAddr[0]
print("[*] Incoming connection from %s." % cltIp)
print("[i] Type %chonker-exit at any prompt to quit Chonker.")
rsock, ssock = socket.socketpair()

t1 = threading.Thread(target = listenerThrd, args = (rsock, cltSkt))
t1.start()

# Free listening socket
lstnSkt.close()

# Prompt settings
promptSession = PromptSession(
    history=FileHistory( historyFile))
style = Style.from_dict({
    '':       '#ff0066', # User input (default text).
    'prompt': '#aa22ff', # Prompt.
})
promptMessage = [
    ('class:prompt', promptStr),
]

while True:
    #with patch_stdout():
    if True:
        cmd = promptSession.prompt(promptMessage,
             auto_suggest = AutoSuggestFromHistory(),
             style = style)
        ssock.sendall(cmd.encode())
        if cmd == '%chonker-exit':
            time.sleep(1)
            ssock.close()
            sys.exit()
