
// -----------------------------------------------------------------------------
//    D E B U G   O U T P U T   H E L P E R S

//



#if defined(STEALTH) || defined(RELEASE)
  #ifdef DEBUG
    #undef DEBUG
  #endif
#endif


#if defined DEBUG || defined RELEASE

  /* Generates a string representing the socket conncetion.
     Returns pointer to string (to be used before next call).
  */
  char* strSocket(SOCKET s){
    static char msgBuffer[64];
    int msgBufferLen = 64;
    int l;
    struct sockaddr_in sAddr;

    getsockname( s, (struct sockaddr*) &sAddr, &sockAddrInSize );
    l = snprintf( msgBuffer, msgBufferLen, "%s:%hu"
      , inet_ntoa(sAddr.sin_addr),  ntohs(sAddr.sin_port) );
    if( l >= msgBufferLen) return msgBuffer;

    getpeername( s, (struct sockaddr*) &sAddr, &sockAddrInSize );
    snprintf( msgBuffer+l, msgBufferLen-l, " <--> %s:%hu"
      , inet_ntoa(sAddr.sin_addr),  ntohs(sAddr.sin_port) );
    if( l >= msgBufferLen) return msgBuffer;
    return msgBuffer;
  }

  /* Generates a string representing the conncetion bridge performed by the
     socket pair.
     Returns pointer to string (to be used before next call).
  */
  char* strConnection(ProxyConnection *conn){
    SOCKET src, dst;
    static char s[128]; // returned string
    int n = 128;        // string max length
    struct sockaddr_in sAddr;
    src = conn->clientskt;
    dst = conn->remoteskt;
    int l = 0;
    // Connection ID
    if( conn->id == 0 ){
      l += snprintf( s+l, n-l, "[---] ");
      if( l >= n ) return s;
    }
    else{
      l += snprintf( s+l, n-l, "[%03d] ", conn->id);
      if( l >= n ) return s;
    }
    // Client socket
    if( src == INVALID_SOCKET ){
      l += snprintf( s+l, n-l,
        "---.---.---.---:---- --> ---.---.---.---:---- ");
      if( l >= n) return s;
    }
    else{
      getpeername( src, (struct sockaddr*) &sAddr, &sockAddrInSize );
      l += snprintf( s+l, n-l, "%s:%hu"
          , inet_ntoa(sAddr.sin_addr),  ntohs(sAddr.sin_port));
      if( l >= n) return s;
      getsockname( src, (struct sockaddr*) &sAddr, &sockAddrInSize );
      l += snprintf( s+l, n-l, " --> %s:%hu (%d)"
           , inet_ntoa(sAddr.sin_addr),  ntohs(sAddr.sin_port), src);
      if( l >= n) return s;
    }
    // Remote socket
    if( dst == INVALID_SOCKET ){
      l += snprintf( s+l, n,
         "== ---.---.---.---:---- --> ---.---.---.---:----");
    }
    else{
      getsockname(dst, (struct sockaddr *) &sAddr, &sockAddrInSize );
      l += snprintf( s+l, n-l, "==(%d) %s:%hu"
          ,dst , inet_ntoa(sAddr.sin_addr),  ntohs(sAddr.sin_port) );
      if( l >= n) return s;
      getpeername( dst, (struct sockaddr*)& sAddr, (int*) &sockAddrInSize );
      l += snprintf( s+l, n-l, " --> %s:%hu"
          , inet_ntoa(sAddr.sin_addr),  ntohs(sAddr.sin_port) );
    }
    return s;
  }

  /* Generate a preview string of the buffer.
     Returns pointer to string (to be used before next call).

     If the buffer is longer than N chars, return first and last N/2 bytes
     separted by [...]. Non printable characters are replaced by dots.
  */
  char* strBuffer(char *buffer, int bufferLen){
    static char msgBuffer[48];
    int msgBufferLen = 48;
    int lenPrint = msgBufferLen - 16;
    char strMid[] = " [...] ";
    int l = 0, i;
    if( msgBufferLen == 0) return 0;
    if( msgBufferLen == 1) goto quit;
    msgBuffer[l++] = '"';
    if( l == msgBufferLen-1) goto quit;
    if( bufferLen > lenPrint ){
      lenPrint /= 2;
      for( i = 0; i < min(lenPrint, msgBufferLen-l-1) ; i++)
        msgBuffer[l++] = (buffer[i] > 31 && buffer[i] < 127) ? buffer[i] : '.';
      if( l == msgBufferLen-1) goto quit;
      for( i = 0; i < min(7, msgBufferLen-l-1) ; i++)
        msgBuffer[l++] = strMid[i];
      if( l == msgBufferLen-1) goto quit;
      for( i = bufferLen - lenPrint; i < min(bufferLen, bufferLen - lenPrint + msgBufferLen-l-1) ; i++)
        msgBuffer[l++] = (buffer[i] > 31 && buffer[i] < 127) ? buffer[i] : '.';
    }
    else{
      for( i = 0; i < min(bufferLen, msgBufferLen-l-1) ; i++)
        msgBuffer[l++] = (buffer[i] > 31 && buffer[i] < 127) ? buffer[i] : '.';
    }
    if( l == msgBufferLen-1) goto quit;
      msgBuffer[l++] = '"';
  quit:
    msgBuffer[l++] = 0;
    return msgBuffer;
  }

#else // SILENT

  #define strSocket(...) 0
  #define strSocketChain(...) 0
  #define strBuffer(...) 0

#endif


#ifdef DEBUG
  /* Debug output function
     Contrary to snprintf these function returns the number of bytes actually
     copied into the buffer
     NOTE: Yes these are therefore badly named, TODO: changename

     The snprintf functions store strings in fixed length static variables
     Use the result before calling again these functions.
  */
  int isDebug = 1;
  #define BUILD_NAME "debug"

  #define errprintf(...) {printf(__VA_ARGS__);}
  #define dbgprintf(...) {printf(__VA_ARGS__);}

  #define fatalError(...){ \
    printf("[X] FATAL ERROR\n"); \
    printf(__VA_ARGS__); \
    exit(EXIT_FAILURE); \
  }



 void printfState(int state){
   // Replace regex:
   // #define PCS_(.*) \(0x.*\)
   // if( state & PCS_$1 ){ printf(" $1");}
   if( state & PCS_SOCKS_V4 ){ printf(" SOCKS_V4");}
   if( state & PCS_SOCKS_V5 ){ printf(" SOCKS_V5");}
   if( state & PCS_AWAIT_SOCKS_HEADER ){ printf(" AWAIT_SOCKS_HEADER");}
   if( state & PCS_AWAIT_SOCKS_COMMAND ){ printf(" AWAIT_SOCKS_COMMAND");}
   if( state & PCS_REMOTE_CONNECT_PENDING ){ printf(" REMOTE_CONNECT_PENDING");}
   if( state & PCS_READY ){ printf(" READY");}
   if( state & PCS_WAIT_SEND_CLIENT ){ printf(" WAIT_SEND_CLIENT");}
   if( state & PCS_WAIT_SEND_REMOTE ){ printf(" WAIT_SEND_REMOTE");}
   if( state & PCS_ERR_CLOSE ){ printf(" ERR_CLOSE");}
   if( state == PCS_NONE ){ printf(" NONE");}
 }


#else
  // RELEASE or SILENT
  // (Almost) No output

  int isDebug = 0;

  #define dbgprintf(...) {}
  #define fatalError(...) { \
    fprintf(stderr,"ERROR "); \
    fprintf(stderr, __VA_ARGS__); \
    exit(EXIT_FAILURE); }

  #if defined RELEASE

    #define BUILD_NAME "release"

    #define errprintf(...) {fprintf(stderr, __VA_ARGS__);}

  #elif defined SILENT

    #define BUILD_NAME "silent"

    // Only outputs fatalerrors
    #define printf(...) {}
    #define errprintf(...) {}
    #undef assert
    #define assert(...) {}

  #endif

#endif


#define PROG_FULLNAME PROG_NAME" v" PROG_VERSION "-" BUILD_NAME
