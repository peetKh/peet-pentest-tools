/*

  Small standalone SOCKS 5 proxy server



  DISCLAIMER: This is a very simple implementation os SOCKS 4 and 5 proxy
  protocoles, that only supports CONNECT command and IPv4 adresses.
  It is not secure, and it might not even be stable.

  USE IT AT YOUR OWN RISKS !!!

  LIMITATIONS
    SOCKS 4:
      - Command: Only TCP CONNECT
    SOCKS 5:
      - Command: Only TCP CONNECT
      - Auth: Only NO_AUTH 0x00
      - AddrType: Only IPv4 (0x01) or hostname (0x03) that represent an Ipv4
        string.
  NOTES:
    - I am not sure I made it right the SOCKS4/5 replies are correct about
      the distant or bind adresses returned.
    - I am not sure the error codes sent back are perfectly matched either.

  This programs uses on an asynchronous approach with calls to select() on
  non blocking sockets.

  Each incoming socket is associated to a forward socket to the distant host,
  and to a state flag. Each time data is received it is processed, appropriate
  replies are sent, and the state of the connection is updated. Then it processes
  all other connections. Once all connections are processed, the program loops
  and wait for event with a select() call.

  If everything works well, this should (hopefully) never  block...
  let's see....


  COMPILATION

    i686-w64-mingw32-gcc -o minisock -DDEBUG main.c -lws2_32
    i686-w64-mingw32-gcc -o minisock -DRELEASE main.c -lws2_32
    i686-w64-mingw32-gcc -o minisock -DSILENT main.c -lws2_32

    Compilation flags

    - DEBUG: For a very verbose output
      Good for debugging
      Do not run in DEBUG w a high N_MAX_CONNECTIONS
      #define DEBUG

    - RELEASE: Minimal output and errors
      #define RELEASE

    - SILENT: Suppress almost all output
      #define SILENT

    Default to DEBUG
    Priority SILENT > RELEASE > DEBUG
    (If SILENT is defined, DEBUG is undefined and RELEASE is assumed.)

  USAGE

    Abort message
    The server will quit if it receives a string starting with "ABORT" instead
    of a SOCKS handshake. All connections will then be closed regardless of what
    is happeing and the program will quit.

  KNOWN BUGS
    - If the connection id count loops at 1000 there might be connections with
      same ID. It isn't a real problem though as the ID number is only for
      monitoring and never used by the code.
    - The program sometimes hangs until I press a key on keybord.
      Why ?
      Answer: https://stackoverflow.com/questions/591047/command-line-windows-hanging-in-rdp-windows

*/

#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <assert.h>

#pragma comment(lib,"ws2_32.lib")

#define PROG_NAME "minisocks"
#define PROG_VERSION "0.1.2"

#define N_MAX_CONNECTIONS 8  // Maximum number of connections
                             // Includes pending connections and ongoing SOCKS handshakes
#define BUFFER_SIZE 4096     // Socket data buffer

// Proxy connection state flags

#define PCS_SOCKS_V4 (0x02)
#define PCS_SOCKS_V5 (0x04)
#define PCS_AWAIT_SOCKS_HEADER (0x0100)
  // Socket accepted, waiting for client to send header
#define PCS_AWAIT_SOCKS_COMMAND (0x0200)
  // SOCKS5 auth sent, awaiting command from client
#define PCS_REMOTE_CONNECT_PENDING (0x0400)
  // SOCKS 4/5 connect() was called.
  // Waiting for distant host response or timeout.
#define PCS_READY (0x0800)
  // SOCKS 4/5 hand shake done and connection.
  // Ready for bidirectionnal data transmission.
#define PCS_WAIT_SEND_CLIENT (0x1000)
  // Received data from remote buffered, waiting to send to client
#define PCS_WAIT_SEND_REMOTE (0x2000)
  // Received data from client buffered, waiting to send to remote
#define PCS_ERR_CLOSE (0x8000)
  // Client and remote connection are to be closed after error occured.
#define PCS_NONE (0x00)
  // No connection
#define PCS_ABORT (0xf00000)
  // Received message to quit
// Masks
#define PCS_MASK_SOCKS_VER  (PCS_SOCKS_V4 | PCS_SOCKS_V5)
  // Flag mask for SOCKS version flags

#define DIR_CLIENT_TO_REMOTE (0)
#define DIR_REMOTE_TO_CLIENT (1)

int sockAddrInSize; // size(struct sockaddr_in*)




// -----------------------------------------------------------------------------
//    D A T A   S T R U C T U R E S

typedef struct _ProxyConnection{
  DWORD id; // connection id number (loops over 1000)
  DWORD state;
  SOCKET clientskt, remoteskt;
  char buffer[BUFFER_SIZE];
  DWORD nBytes,  nBytesSent;
} ProxyConnection;

// Helper functions

#include "helpers.h"

// -----------------------------------------------------------------------------
//    S O C K S   H A N D S H A K E   A N D   F W D   C O N N E C T I O N
/*
    These functions perform one step of the SOCKS handshake when data is
    received or a connection established.

    They processes inputs, sends replies, opens the socket to the remote host,
    and update connection state.
    Returns 0 if success.

    On error the state is set to PCS_ERR_CLOSE, it sends a response to the
    client if appropriate, and returns non-zero.
    The caller must then close all sockets of the connection.
*/
int handleSocksHandshake_ProcessHeader(ProxyConnection *conn);
int handleSocksHandshake_ProcessAuthMethod(ProxyConnection *conn);
int handleSocksHandshake_ProcessCommand(ProxyConnection *conn);
int handleSocksHandshake_Connect(ProxyConnection *conn);
int handleSocksHandshake_ConnectFail(ProxyConnection *conn);
int handleSocksHandshake_SendReply(ProxyConnection *conn, int statusCode);
int handleSocksHandshake_ConnectSuccess(ProxyConnection *conn);

/* SOCKS 4/5 : Process client header
 */
int handleSocksHandshake_ProcessHeader(ProxyConnection *conn){

  int i;
  char abortMessage[] = "ABORT";
  char *buffer = conn->buffer;
  int bufferLen = conn->nBytes;

  conn->state = 0;
  conn->remoteskt = INVALID_SOCKET;

  // -- Recv client header --
  // [ VER | ...(SOCKS4/5 HEADER)... ]
  #ifdef DEBUG
    dbgprintf("    Rcv client header:");
    for( int i = 0; i < bufferLen; i++ )
      dbgprintf(" %02hhx", buffer[i]);
    dbgprintf("\n");
  #endif

  // Check SOCKS version
  if( bufferLen < 2 ){
    errprintf("    ERROR: Invalid SOCKS header length\n");
    return 1;
  }
  switch( buffer[0] ){
    case 4: // SOCKS 4
      conn->state = PCS_SOCKS_V4 | PCS_AWAIT_SOCKS_COMMAND;
      dbgprintf("    SOCKS 4.\n");
      return handleSocksHandshake_ProcessCommand(conn);

    case 5: // SOCKS 5
      conn->state = PCS_SOCKS_V5 | PCS_AWAIT_SOCKS_HEADER;
      dbgprintf("    SOCKS 5.\n");
      return handleSocksHandshake_ProcessAuthMethod(conn);

    case 'A': // ABORT PACKET

      for( i = 0;  i < strlen(abortMessage) && buffer[i] == abortMessage[i] ; i++) {};
      if( i== strlen(abortMessage) ){
          printf("[!] Received abort message.\n");
          conn->state = PCS_ABORT;
          return 0;
      }
    default:
      errprintf("    ERROR: Invalid SOCKS version\n");
      return 2;
  }
}

/* SOCKS 5 : Process auth method
 */
int handleSocksHandshake_ProcessAuthMethod(ProxyConnection *conn){
  char *buffer = conn->buffer;
  int bufferLen = conn->nBytes;

  // SOCKS 5
  assert( conn->state == (PCS_SOCKS_V5|PCS_AWAIT_SOCKS_HEADER) );

  // -- Parse client auth header
  // [ VER | NMETHODS | METHOD_1 | ... | METHOD_N ]

  int nMethods = buffer[1];
  int errorCode = 0;
  if( nMethods + 2 == bufferLen ){
    #ifdef DEBUG
      dbgprintf("    Client auth methods:");
      for( int i = 0; i < nMethods; i++)
        dbgprintf(" %02hhx", buffer[i+2]);
      dbgprintf("\n");
    #endif
    bool foundAuth = 0;
    bool foundAuth_NoAuth = 0;
    for( int i = 0; i < nMethods; i++ ){
      if( buffer[i+2] == 0 )
        foundAuth_NoAuth = 1;
        foundAuth = 1;
    }
    if( !foundAuth ){
      errprintf("    ERROR: No compatible AUTH METHOD found.\n");
      errorCode = 0xff;
    }
  }
  else{
    errprintf("   ERROR: Invalid AUTH METHOD list\n");
    errorCode = 0xff;
  }
  // TODO :  Auth Method 0x02 User/Password

  // -- Send server header --
  // [ SOCKS_VERSION | AUTH_METHOD ]
  // AuthMethod: NoAuth 0x00
  buffer[0] = 5;
  buffer[1] = (errorCode == 0) ? 0 : 0xff ;
  send( conn->clientskt, buffer, 2, 0 );
  if( errorCode ){
    conn->state = PCS_NONE;
    return 6;
  }

  dbgprintf("    SOCKS 5: Auth sent, awaiting command.\n");
  conn->state = PCS_SOCKS_V5 | PCS_AWAIT_SOCKS_COMMAND;
  return 0;
}

/* SOCKS 4/5 : Sends SOCKS handshake reply to client.

   StatusCode corresponds to SOCKS 5 status/error codes and is translated to
   SOCKKS4 equivalent if protocol is SOCKS 4.
 */
int handleSocksHandshake_SendReply(ProxyConnection *conn, int statusCode){

  char buffer[32];
  int nBytes;
  struct sockaddr_in bndAddr, dstAddr;

  assert( conn->state & (PCS_SOCKS_V4|PCS_SOCKS_V5) );
  if( statusCode == 0 ){
    assert( conn->remoteskt != INVALID_SOCKET );
    getsockname( conn->remoteskt, (struct sockaddr *) &bndAddr, &sockAddrInSize );
    getpeername( conn->remoteskt, (struct sockaddr *) &dstAddr, &sockAddrInSize );
  }
  else{
    dstAddr.sin_port = 0;
    dstAddr.sin_addr.s_addr = 0;
    bndAddr.sin_port = 0;
    bndAddr.sin_addr.s_addr = 0;
  }

  if( conn->state & PCS_SOCKS_V4 ){
    // SOCKS 4 reply
    // [ VN | REP | DSTPORT | DSTIP ]
    buffer[0] = 0;
    buffer[1] = (statusCode == 0) ? 0x5a : 0x5b; // Convert errorCode SOCKS4
    *((uint16_t *)(buffer+2)) = dstAddr.sin_port;
    *((uint32_t *)(buffer+4)) = dstAddr.sin_addr.s_addr;
    nBytes = 8;
  }
  if( conn->state & PCS_SOCKS_V5 ){
    // SOCKS 5 reply
    // [ VER | REP | RSV | ATYP | BND.ADDR | BND.PORT ]
    buffer[0] = 5;
    buffer[1] = statusCode;
    buffer[2] = 0;
    buffer[3] = 1;
    *((uint32_t *)(buffer+4)) = bndAddr.sin_addr.s_addr;
    *((uint16_t *)(buffer+8)) = bndAddr.sin_port;
    nBytes = 10;
  }
  send( conn->clientskt, buffer, nBytes, 0 );
}

/*  SOCKS 4/5 : Process client command and initiate connection to remote host
 */
int handleSocksHandshake_ProcessCommand(ProxyConnection *conn){
  char *buffer = conn->buffer;
  int bufferLen = conn->nBytes;
  int i, err, wsaErr;
  struct sockaddr_in dstAddr, bndAddr;
  uint8_t errorCode = 0;
  uint8_t strLen;

  assert( (conn->state & PCS_SOCKS_V4) ^ (conn->state & PCS_SOCKS_V5) );
  assert( conn->state & PCS_AWAIT_SOCKS_COMMAND );
  #ifdef DEBUG
    dbgprintf("    Rcv client command:");
    for( i = 0; i < bufferLen; i++)
      dbgprintf(" %02hhx", buffer[i]);
    dbgprintf("\n");
  #endif
  dstAddr.sin_family = AF_INET;

  // -- Parse command SOCKS 4/5 --

  if( conn->state & PCS_SOCKS_V4 ){
    // SOCKS 4
    // [ VER | CMD | DST.PORT | DST.ADDR | ID ]
    if( bufferLen >= 9){
      if( buffer[1] == 1 ){ // 0x01 : CONNECT
        dstAddr.sin_addr.s_addr = *( (uint32_t *)(buffer+4) );
        dstAddr.sin_port = *( (uint16_t *)(buffer+2) );
        int i;
        dbgprintf("    ID:\"");
        for( i = 8; i < bufferLen && buffer[i] != 0; i++){
          #ifdef DEBUG
            putchar( (buffer[i]<32 || buffer[i]>126) ? '.' : buffer[i]);
          #endif
        }
        dbgprintf("\"\n");
        if( buffer[i] == 0){
          // OK
          // NOTE: We don't care for ID
          errorCode = 0;
          // Ready to open Remote socket
        }
        else{
          errprintf("    ERROR: ID not terminated by NULL byte\n");
          return 3;
        }
      }
      else{
        errprintf("    ERROR: Invalid SOCKS4 command\n");
        return 4;
      }
    }
    else{
      errprintf("    ERROR: Invalid SOCKS4 header size\n");
      return 5;
    }
  }
  if( conn->state & PCS_SOCKS_V5 ){
    // SOCKS 5
    // [ VER | CMD | RESERVED 0x00 | ADDR.TYPE | DST.ADDR | DST.PORT ]
    // Check buffer validity
    if( bufferLen >= 10 && buffer[0] == 5 && buffer[2] == 0 ){
      // Parse COMMAND
      if( buffer[1] == 1 ){ // 0x01 : CONNECT
        // Parse ADDR_TYPE, ADDR and PORT
        switch( buffer[3] ){
          case 1: // 0x01 : IPv4
            if( bufferLen == 10 ){
              dstAddr.sin_addr.s_addr = *( (uint32_t *)(buffer+4) );
              dstAddr.sin_port = *( (uint16_t *)(buffer+8) );
            }
            else{
               errprintf("    ERROR: Invalid Ipv4 address length\n");
               errorCode = 1;
            }
            break;
          case 3: // 0x03 : Hostname
            // NOTE: Accept only strings representing an IPv4 address
            // No host resolution
            strLen = buffer[4];
            if( bufferLen == 7 + strLen ){
              dstAddr.sin_port = *( (uint16_t *) (buffer+5+strLen) );
              buffer[5+strLen] = 0;
              dstAddr.sin_addr.s_addr = inet_addr( buffer+5 );
              if( dstAddr.sin_addr.s_addr == INADDR_NONE ){
                // Not an IP address, not doing DNS resolution !!
                errprintf("    ERROR: Cannot resolve hostname.\n");
                errorCode = 4; // 0x04 Host unreachable
              }
            }
            else{
               errprintf("    ERROR: Invalid hostname length.\n");
               errorCode = 1;
            }
            break;
          default:
            errprintf("    ERROR: Address type %02hhx not supported.\n", buffer[3]);
            errorCode = 8; // 0x08 Address type not supported
        }
      }
      else{
        errprintf("    ERROR: command %02hhx not supported.\n", buffer[1]);
        errorCode = 7; // 0x07 Command not supported
      }
    }
    else{
      errprintf("    ERROR: Invalid command buffer\n");
      errorCode = 1;
    }
  }

  if( errorCode ){
    handleSocksHandshake_SendReply(conn, errorCode );
    conn->state = PCS_ERR_CLOSE;
    return 6;
  }

  // -- Initiate connection to distant host --

  dbgprintf("    Request CONNECT to %s:%d.\n"
    , inet_ntoa(dstAddr.sin_addr), ntohs(dstAddr.sin_port));
  unsigned long ul;

  // Create socket
  conn->remoteskt = socket(AF_INET, SOCK_STREAM, 0);
  if( conn->remoteskt != INVALID_SOCKET ){

    // Set non blocking
    ul = 1;
    err = ioctlsocket(conn->remoteskt, FIONBIO, &ul);
    if( !err ){

      // Connect
      dbgprintf("    Connecting to %s:%d.\n"
        , inet_ntoa(dstAddr.sin_addr), ntohs(dstAddr.sin_port));
      err = connect(conn->remoteskt, (struct sockaddr*) &dstAddr, sockAddrInSize);
      if( !err ){
        // Connected immediately
        // TODO: Is that even possible in non-blocking mode ?
        return handleSocksHandshake_ConnectSuccess(conn);
      }
      else{// connect(...) == SOCKET_ERROR
        assert( err == SOCKET_ERROR );
        wsaErr = WSAGetLastError();
        if( wsaErr == WSAEWOULDBLOCK ){
          // Connection pending, put it in background
          dbgprintf("    Connection initiated (would block). Resuming other operations.\n");
          conn->state = (conn->state & PCS_MASK_SOCKS_VER) | PCS_REMOTE_CONNECT_PENDING;
          return 0;
        }
        else{
          //TODO Take care of other recoverable error, if any
          //TODO Issue correct SOCKS error code to client if appropriate
          errprintf("    ERROR: While initiating connection: %d.\n", wsaErr);
        }
      }
    }
    else{// ioctlsocket(*fs, FIONBIO, &ul) == SOCKET_ERROR
      assert( err == SOCKET_ERROR );
      wsaErr = WSAGetLastError();
      errprintf("    ERROR: Failed to set socket non blocking : %d.\n", wsaErr );
    }
    closesocket(conn->remoteskt);
    conn->remoteskt = INVALID_SOCKET;
    errorCode = 1;
  }
  else{// *fs == INVALID_SOCKET
    assert( conn->remoteskt == INVALID_SOCKET );
    wsaErr = WSAGetLastError();
    errprintf("    ERROR: Could not create socket : %d.\n", wsaErr);
    errorCode = 1;
  }

  assert( errorCode );

  handleSocksHandshake_SendReply(conn, errorCode);
  conn->state = PCS_ERR_CLOSE;
  return 7;
}

/* Connection to host successfull, send reply to client and set ready
 */
int handleSocksHandshake_ConnectSuccess(ProxyConnection *conn){

  assert( (conn->state & PCS_SOCKS_V4) ^ (conn->state & PCS_SOCKS_V5) );
  assert( conn->state & PCS_REMOTE_CONNECT_PENDING );

  handleSocksHandshake_SendReply(conn, 0x00);
  conn->state = PCS_READY;
  printf( "[*]-[%03d] Connection established.\n    %s.\n"
    , conn->id, strConnection(conn));
  dbgprintf("    Connection is READY.\n");
  return 0;
}

/* SOCKS 4/5 Connection to distant host failed
 */
int handleSocksHandshake_ConnectFail(ProxyConnection *conn){
  // Get socket error code and map it to SOCKS5 error code if possible
  uint32_t optVal;
  int socks5errorCode, retVal, optLen = 4;

  assert( (conn->state & PCS_SOCKS_V4) ^ (conn->state & PCS_SOCKS_V5) );
  assert( conn->state & PCS_REMOTE_CONNECT_PENDING );

  retVal = getsockopt(conn->remoteskt, SOL_SOCKET, SO_ERROR, (char*) &optVal, &optLen);
  if( retVal != 0 ){
    errprintf("    ERROR getsockopt FAILED !!\n");
    socks5errorCode = 0x01 ;// General failure
  }
  else{
    dbgprintf("    Socket error code: %d ", optVal, optVal);
    switch( optVal ){
      // Errors that have a direct translation in socks5 error codes
      case WSAENETUNREACH:
        dbgprintf("Network unreachable");
        socks5errorCode = 0x03; break;
      case WSAEHOSTUNREACH:
        dbgprintf("Host uneachable");
        socks5errorCode = 0x04;
      case WSAECONNREFUSED:
        dbgprintf("Connection refused by destination host");
        socks5errorCode = 0x05; break;
      // Other errors, mapped to 0x01 : General error
      default:
        socks5errorCode = 0x01;
        #ifdef DEBUG // Output for debugging
        switch( optVal ){
          case WSAECONNRESET:dbgprintf("Connection reset by dst host"); break;
          case WSAETIMEDOUT:dbgprintf("Connection tiemed out");break;
          case WSAEHOSTDOWN:dbgprintf("Host down");break;
          case WSAHOST_NOT_FOUND:dbgprintf("Host not found");break;
          default:dbgprintf("Other error");
        }
        #endif
    }
  }
  dbgprintf("\n");
  handleSocksHandshake_SendReply(conn, socks5errorCode );
  conn->state = PCS_ERR_CLOSE;
  dbgprintf("    Connection to distant host failed. Closing.\n");
  return 8;
}


// -----------------------------------------------------------------------------
//    P R O X Y   F U N C T I O N S

/* Receive data from socket, place it in buffer and update state on error.
 */
int recvBuffer(ProxyConnection *conn, SOCKET s){
  int retVal, wsaErr;

  // ** recv() **
  retVal = recv( s, conn->buffer, BUFFER_SIZE-1, 0 );
  if( retVal != SOCKET_ERROR && retVal > 0 ){
    conn->nBytes = retVal;
    conn->nBytesSent = 0;
    return 0;
  }
  else{ // nBytes == SOCKET_ERROR || nBytes == 0
    //TODO : Rename PCS_ERR_CLOSE or make other state for gracefull close
    //TODO : This should ideally be in a separate function
    wsaErr = WSAGetLastError();
    if( wsaErr == WSAECONNRESET ){
      // Connection reset
      errprintf( "[X]-[%03d] Socket reset\n    %s.\n"
          , conn->id, strSocket(s));
    }
    else if( retVal == 0 ){
      // Connection gracefully closed
      errprintf( "[X]-[%03d] Socket closed\n    %s.\n"
          , conn->id, strSocket(s));
      // XXX
    }
    else{
      // Connection terminated
      errprintf( "[X]-[%03d] Socket failed with WSA Error %d\n    %s.\n"
          , conn->id, wsaErr, strSocket(s));
    }
    conn->state = PCS_ERR_CLOSE;
    return 1;
  }
}

/* Sends data buffered in connection->buffer on clientskt/remoteskt.

   If send() blocks or does not send all buffer, keep remaining data in buffer
   and update state to PCS_WAIT_SEND_CLIENT/REMOTE.
*/
int sendBuffer(ProxyConnection *conn, int dir){
  int wsaErr, nBytesSent, retVal, waitTime;
  SOCKET s;

  if( dir == DIR_REMOTE_TO_CLIENT )
    s = conn->clientskt;
  if( dir == DIR_CLIENT_TO_REMOTE )
    s = conn->remoteskt;

  // ** send() **
  int nBytesToSend = conn->nBytes - conn->nBytesSent;
  retVal = send( s, conn->buffer + conn->nBytesSent, nBytesToSend, 0 );

  if( retVal == SOCKET_ERROR ){
    wsaErr = WSAGetLastError();
    if( wsaErr != WSAEWOULDBLOCK ){
      errprintf("    SOCKET ERROR %d while sending.\n", wsaErr);
      conn->state = PCS_ERR_CLOSE;
      return 1;
    }
    else{ //  wsaErr == WSAEWOULDBLOCK
      // Socket buffer is full
      // Will send remaining after writefds event
      dbgprintf( "[!] Could not send data on socket %d (buffering and wait).\n    %s\n"
        , s, strConnection(conn));
    }
  }
  else{
    if( retVal == nBytesToSend ){
      // Sent all, ok
      conn->state = PCS_READY;
      conn->nBytes = 0;
      conn->nBytesSent = 0;
      return 0;
    }
    else{
      // Could not send all data
      conn->nBytesSent += retVal;
      dbgprintf("    Only sent %d/%d bytes. Buffering the remaining.\n"
          , retVal, nBytesToSend);
    }
  }

  if( dir == DIR_REMOTE_TO_CLIENT )
    conn->state = PCS_WAIT_SEND_CLIENT;
  if( dir == DIR_CLIENT_TO_REMOTE )
    conn->state = PCS_WAIT_SEND_REMOTE;
  return 1;
}


// -----------------------------------------------------------------------------
//    M A I N   L O O P


int main(int argc , char *argv[])
{
  puts(PROG_FULLNAME "\r\n");
  int proxyListenPort = 9090;
  int proxyListenAddr = INADDR_ANY ;
  // int proxyListenAddr = inet_addr("127.0.0.1");

  WSADATA wsa;
  struct sockaddr_in lstSockAddr;
  SOCKET lstSkt, s, cs, rs;
  ProxyConnection connections[N_MAX_CONNECTIONS], *conn;
  int connectionCount = 0;
  // TIMEVAL selectTimeout;
  int i, selectCallTries;
  sockAddrInSize = sizeof(struct sockaddr_in);

  dbgprintf("NOTES\n SOCKET_ERROR = %d\n INVALID_SOCKET = %d\n",
    SOCKET_ERROR, INVALID_SOCKET );
  dbgprintf("IsDebug : %d\n", isDebug);

  // ------ Start listening socket -----

  // Startup WinSock
  if( WSAStartup(MAKEWORD(2,2), &wsa) != 0 )
    fatalError("Failed to start WinSock", WSAGetLastError());

  // Create listening socket
  lstSkt = socket(AF_INET, SOCK_STREAM, 0 );
  if( lstSkt == INVALID_SOCKET )
    fatalError("Failed to create listening socket", WSAGetLastError());

  // Set non blocking
  unsigned long ul = 1;
  if( ioctlsocket(lstSkt, FIONBIO, &ul) == SOCKET_ERROR )
    fatalError("Failed to set socket non blocking", WSAGetLastError());

  // Bind socket
  lstSockAddr.sin_family = AF_INET;
  lstSockAddr.sin_addr.s_addr = proxyListenAddr;
  lstSockAddr.sin_port = htons(proxyListenPort);
  if( bind( lstSkt, (struct sockaddr *) &lstSockAddr, sizeof(lstSockAddr)) == SOCKET_ERROR)
    fatalError( "Failed to bind socket", WSAGetLastError() );
  getsockname( lstSkt, (struct sockaddr*) &lstSockAddr, &sockAddrInSize );

  // Listen
  listen( lstSkt, 5 );
  printf( "[+] Listening on %s.\n", inet_ntoa(lstSockAddr.sin_addr) );

  // ----- Receive and handle connnections -----

  int nActiveConnections = 0;
  // Initialize data structures
  for( i = 0; i < N_MAX_CONNECTIONS; i++){
    connections[i].state = PCS_NONE;
    connections[i].clientskt = INVALID_SOCKET;
    connections[i].remoteskt = INVALID_SOCKET;
    connections[i].id = 0;
  }

  int nBytes, nBytesSent;
  int nEvents, wsaErr, errorCode;
  struct sockaddr_in sAddr;
  char buffer[BUFFER_SIZE];
  fd_set readfds, writefds, exceptfds;

  // selectTimeout.tv_sec = 5;
  // selectTimeout.tv_usec = 0;
  bool exec = 1;
  while( exec ){

    // ----- Query activity on sockets -----

    FD_ZERO(&readfds);
    FD_ZERO(&writefds);
    FD_ZERO(&exceptfds);
    if( nActiveConnections < N_MAX_CONNECTIONS ){
      // Polling new connection only if we can accept them
      FD_SET(lstSkt, &readfds);
    }
    for(int  i = 0 ; i < N_MAX_CONNECTIONS ; i++){
      // open connections
      if( connections[i].state == PCS_READY){
        FD_SET(connections[i].clientskt, &readfds);
        FD_SET(connections[i].remoteskt, &readfds);
      }
      else if( connections[i].state == PCS_WAIT_SEND_CLIENT){
        FD_SET(connections[i].clientskt, &writefds);
      }
      else if( connections[i].state == PCS_WAIT_SEND_REMOTE){
        FD_SET(connections[i].remoteskt, &writefds);
      }
      else if( connections[i].state & PCS_REMOTE_CONNECT_PENDING){
        FD_SET(connections[i].remoteskt, &writefds);
        FD_SET(connections[i].remoteskt, &exceptfds);
      }
      else if( connections[i].state & (PCS_AWAIT_SOCKS_HEADER|PCS_AWAIT_SOCKS_COMMAND) ){
        // Socks handshake ongoing
        FD_SET(connections[i].clientskt, &readfds);
      }
    }

    #ifdef DEBUG // Output connections before select()
      dbgprintf("\n\n\nSockets to poll:\n");
      dbgprintf("   == [LST] (%d) %s:%d\n      Events: ", lstSkt
        , inet_ntoa(lstSockAddr.sin_addr),  ntohs(lstSockAddr.sin_port));
      if( FD_ISSET(lstSkt, &readfds) )   dbgprintf(" LstREAD");
      if( FD_ISSET(lstSkt, &writefds) )  dbgprintf(" LstWRITE");
      if( FD_ISSET(lstSkt, &exceptfds) ) dbgprintf(" LstEXCEPT");
      dbgprintf("\n");
      for( i = 0 ; i < N_MAX_CONNECTIONS ; i++){
        dbgprintf("   %02d %s\n", i, strConnection(&connections[i]));
        dbgprintf("      State: %04x", connections[i].state);
        printfState(connections[i].state);
        dbgprintf("\n      Poll evt: ");
        if( FD_ISSET(connections[i].clientskt, &readfds) )   dbgprintf(" ClientREAD");
        if( FD_ISSET(connections[i].clientskt, &writefds) )  dbgprintf(" ClientWRITE");
        if( FD_ISSET(connections[i].clientskt, &exceptfds) ) dbgprintf(" ClientEXCEPT");
        if( FD_ISSET(connections[i].remoteskt, &readfds) )   dbgprintf(" RemoteREAD");
        if( FD_ISSET(connections[i].remoteskt, &writefds) )  dbgprintf(" RemoteWRITE");
        if( FD_ISSET(connections[i].remoteskt, &exceptfds) ) dbgprintf(" RemoteEXCEPT");
        dbgprintf("\n");
      }
    #endif

    dbgprintf("Calling select(). Waiting for event...");
    nEvents = select( 0, &readfds, &writefds, &exceptfds, NULL );
    if( nEvents == SOCKET_ERROR ){
      if( selectCallTries++ >= 3)
        fatalError( "Failed call to select() on socket list", WSAGetLastError() );
      dbgprintf("\n[!] select() call failed with code %d.\n", WSAGetLastError() );
      continue;
    }
    else
      selectCallTries = 0;
    dbgprintf(" Done.\n");

    #ifdef DEBUG // Output select() result
      dbgprintf("Poll result select():\n");
      dbgprintf("   == [LST] (%d) %s:%d\n      Events: ", lstSkt
        , inet_ntoa(lstSockAddr.sin_addr),  ntohs(lstSockAddr.sin_port));
      if( FD_ISSET(lstSkt, &readfds) )   dbgprintf(" LstREAD");
      if( FD_ISSET(lstSkt, &writefds) )  dbgprintf(" LstWRITE");
      if( FD_ISSET(lstSkt, &exceptfds) ) dbgprintf(" LstEXCEPT");
      dbgprintf("\n");
      for( i = 0 ; i < N_MAX_CONNECTIONS ; i++ ){
        dbgprintf("   %02d %s\n", i, strConnection(&connections[i]));
        dbgprintf("      Events: ");
        if( FD_ISSET(connections[i].clientskt, &readfds) )   dbgprintf(" ClientREAD");
        if( FD_ISSET(connections[i].clientskt, &writefds) )  dbgprintf(" ClientWRITE");
        if( FD_ISSET(connections[i].clientskt, &exceptfds) ) dbgprintf(" ClientEXCEPT");
        if( FD_ISSET(connections[i].remoteskt, &readfds) )   dbgprintf(" RemoteREAD");
        if( FD_ISSET(connections[i].remoteskt, &writefds) )  dbgprintf(" RemoteWRITE");
        if( FD_ISSET(connections[i].remoteskt, &exceptfds) ) dbgprintf(" RemoteEXCEPT");
        dbgprintf("\n");
      }
    #endif

    // ----- Incoming connection on listening socket -----

    if( FD_ISSET( lstSkt, &readfds) ){
      nEvents--;
      if( nActiveConnections < N_MAX_CONNECTIONS ){
        s = accept(lstSkt, (struct sockaddr *) &sAddr, (int *) &sockAddrInSize);
        dbgprintf( "[+] Accepting new connection from %s:%d.\n"
          , inet_ntoa(sAddr.sin_addr),  ntohs(sAddr.sin_port) );

        if( s != INVALID_SOCKET ){
          // Find available connection id
          for( i = 0; i < N_MAX_CONNECTIONS; i++)
            if( connections[i].state == PCS_NONE)
              break;
          connections[i].id = ++connectionCount % 1000;
          connections[i].clientskt = s;
          connections[i].remoteskt = INVALID_SOCKET;
          connections[i].state = PCS_AWAIT_SOCKS_HEADER;
          nActiveConnections++;
          printf( "[*]-[%03d] New connection from %s:%d.\n", connections[i].id
            , inet_ntoa(sAddr.sin_addr),  ntohs(sAddr.sin_port) );
        }
        else{ // s == INVALID_SOCKET
          errprintf("[X] Failed to receive incoming connection WSAError %d"
            , WSAGetLastError());
          closesocket( s );
        }
      }
      else{ //  nActiveConnections == N_MAX_CONNECTIONS
        errprintf("[X] Received new connection attempt but too many connections already.");
        // We don't accept the connection, hopefully we'll be able to accept it
        // later
        // TODO Check implications and performance
        dbgprintf("[~] Not accepting connection.");
        //  // Old code for rejecting connection on the spot
        //  dbgprintf("[~] Rejecting connection.");
        //  s = accept(lstSkt, (struct sockaddr *) &sAddr, (int *) &sockAddrInSize);
        //  closesocket( s );
      }
    }

    // -- Remote sockets write and except --

    for( i = 0; i < N_MAX_CONNECTIONS; i++ ){
      conn = &(connections[i]);
      cs = conn->clientskt;
      rs = conn->remoteskt;

      // Remote except event
      if( FD_ISSET(rs, &exceptfds) ){
        nEvents--;
        if( conn->state & PCS_REMOTE_CONNECT_PENDING ){
           // Pending connection failed
           dbgprintf("[*]-[%03d] Connection to remote host failed. Closing connection.\n    %s.\n"
             , conn->id, strSocket(rs));
           handleSocksHandshake_ConnectFail(conn);
        }
        else{
          errprintf("[!]-[%03d] ERROR: Unexpected exception. Closing connection.\n    %s.\n"
            , conn->id, strSocket(rs));
          conn->state = PCS_ERR_CLOSE;
        }
      }

      // Remote write event
      if( FD_ISSET(rs , &writefds) ){
        nEvents--;
        dbgprintf("[i]-[%03d]  % 4d -> % 4d : Write event.\n", conn->id, cs, rs);
        if( conn->state & PCS_REMOTE_CONNECT_PENDING ){
          // Pending connection succeeded
          handleSocksHandshake_ConnectSuccess(conn);
        }
        else if( conn->state & PCS_WAIT_SEND_REMOTE ){
          // Socket is ready for sending buffered data
          sendBuffer(conn, DIR_CLIENT_TO_REMOTE);
        }
        else
          errprintf("Unexpected connection state for remote writefds event.\n");
      }

      // Client Write event
      if( FD_ISSET(cs, &writefds) ){
        nEvents--;
        dbgprintf("[i]-[%03d]  % 4d -> % 4d : Write event.\n", conn->id, cs, rs);
        if( conn->state & PCS_WAIT_SEND_CLIENT ){
          // Socket is ready for sending buffered data
          sendBuffer(conn, DIR_REMOTE_TO_CLIENT);
        }
        else
          errprintf("Unexpected connection state for client writefds event.\n");
      }

      // Client Read event
      if( FD_ISSET(cs, &readfds) ){
        nEvents--;
        errorCode = recvBuffer(conn, conn->clientskt);
        if( !errorCode ){
          if( conn->state == PCS_READY ){
            // Connection ready, just forward data
            dbgprintf( "[>]-[%03d] Transferring %d bytes of data on connection\n"
                  "    %s\n    %s\n" , conn->id, conn->nBytes, strConnection(conn)
                  , strBuffer(conn->buffer, conn->nBytes));
            sendBuffer(conn, DIR_CLIENT_TO_REMOTE);
          }
          else if( conn->state & PCS_AWAIT_SOCKS_HEADER ){
            // Start SOCKS handshake
            // ** SOCKS Handshake **
            dbgprintf( "[*]-[%03d] Initiating SOCKS handshake with client %s:%d.\n"
              , conn->id, inet_ntoa(sAddr.sin_addr),  ntohs(sAddr.sin_port) );
            errorCode = handleSocksHandshake_ProcessHeader(conn);
            if( conn->state == PCS_ABORT ){
              // Abort flag: quit
              exec = 0;
            }
          }
          else if( conn->state & PCS_AWAIT_SOCKS_COMMAND ){
            //// Resume SOCKS 5 handshake at receive command
            // ** SOCKS Handshake **
            dbgprintf( "[*]-[%03d] Resuming SOCKS 5 handshake with client %s:%d.\n"
              , conn->id, inet_ntoa(sAddr.sin_addr),  ntohs(sAddr.sin_port) );
            errorCode = handleSocksHandshake_ProcessCommand(conn);
          }
          else{
            // Received data from client before remote host connection
            // established. Should not happend, or else the client is impatient
            // and started sending data before getting confirmation connection
            // is established.
            printf( "[!]-[%03d] Received data from client but connection"
              "to remote host not ready.\n    %s\n", conn->id, strConnection(conn));
            dbgprintf("[~] Ignoring received data.");
            // send( fs, buffer, nBytes, 0 );
          }
          // temporary code to check for error
          if( errorCode )
            assert( conn->state == PCS_ERR_CLOSE);
        }
      }

      // Remote read event
      if( FD_ISSET( rs, &readfds )){
        nEvents--;
        if( conn->state == PCS_READY ){
          // Receive data
          errorCode = recvBuffer(conn, conn->remoteskt);
          if( !errorCode ){
            // Connection ready, just forward data
            dbgprintf( "[<]-[%03d] Transferring %d bytes of data on connection\n"
                  "    %s\n    %s\n" , conn->id, conn->nBytes, strConnection(conn),
                  strBuffer(conn->buffer, conn->nBytes));
            sendBuffer(conn, DIR_REMOTE_TO_CLIENT);
          }
        }
        else{
          // Received data but SOCKS handshake not finished
          // May happen if REMOTE immediately sends header before the proxy
          // could send the SOCKS reply and set the connecton READY.
          // just wait.. and hope the socket buffer won't be emptied
          errprintf( "[!]-[%03d] Received data from remote host but connection"
            "not ready.\n    %s\n", conn->id, strConnection(conn));
          dbgprintf("[~] Ignoring received data.\n");
          // send( fs, buffer, nBytes, 0 );
        }
      }

    } // for

    // ---- Close all connections in state PCS_ERR_CLOSE ----

    for( i = 0; i < N_MAX_CONNECTIONS; i++ ){
      if( connections[i].state & PCS_ERR_CLOSE ){
        conn = &connections[i];
        printf( "[-] [%03d] Closing connection\n    %s.\n", conn->id
          , strConnection(conn));
        // Closing connections
        shutdown(conn->clientskt, SD_SEND);
        shutdown(conn->remoteskt, SD_SEND);
        closesocket(conn->clientskt);
        closesocket( conn->remoteskt);
        conn->clientskt = INVALID_SOCKET;
        conn->remoteskt = INVALID_SOCKET;
        conn->state = PCS_NONE;
        conn->id = 0;
        nActiveConnections--;
      }
    }

    if( nEvents ){
      printf("[*] %d unprocesed events.\n", nEvents);
    }
  } // while

  // ---- Quitting ----


  printf("[*] Quitting. Closing all connections.\n");

  printf("[-] == [LST] (%d) %s:%d\n    Closing listener... ", lstSkt
    , inet_ntoa(lstSockAddr.sin_addr),  ntohs(lstSockAddr.sin_port));
  closesocket(lstSkt);
  printf("Closed.\n");

  for( i = 0; i < N_MAX_CONNECTIONS; i++ ){
    if( (cs = connections[i].clientskt) == INVALID_SOCKET
        && (rs = connections[i].remoteskt) == INVALID_SOCKET ){
      printf( "[-] %02d %s.\n    No active connection.\n", i
        , strConnection(&connections[i]));
    }
    else {
      printf( "[-] %02d %s.\n    Closing... ", i, strConnection(&connections[i]));
      if( cs != INVALID_SOCKET ) shutdown( cs, SD_SEND );
      if( rs != INVALID_SOCKET ) shutdown( rs, SD_SEND );
      if( cs != INVALID_SOCKET ) closesocket( cs );
      if( rs != INVALID_SOCKET ) closesocket( rs );
      printf("Closed.\n");
    }
  }

  WSACleanup();

  printf("Bye");
  exit(0);
}
